{
  "comments": [
    {
      "key": {
        "uuid": "0c046456_4eef6a42",
        "filename": "libs/cputimeinstate/cputimeinstate.cpp",
        "patchSetId": 1
      },
      "lineNbr": 277,
      "author": {
        "id": 1069543
      },
      "writtenOn": "2020-02-03T23:11:43Z",
      "side": 1,
      "message": "are we sure 1s is enough? What is the penalty for getting this wrong and missing an update?",
      "revId": "f92ace0a56c6bae80c7f351e1fd6ae94d172c27f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e9b6113_d2330c58",
        "filename": "libs/cputimeinstate/cputimeinstate.cpp",
        "patchSetId": 1
      },
      "lineNbr": 277,
      "author": {
        "id": 1115183
      },
      "writtenOn": "2020-02-03T23:39:30Z",
      "side": 1,
      "message": "The penalty is that the update wouldn\u0027t be read until 1) the UID ran again resulting in a more recent update time and then 2) getUidsUpdated*Times was called after that. The possible error in the meantime would be bounded by how long the getUidsUpdated*Times functions take to iterate through the uid_last_update_map (since we aren\u0027t at risk of missing updates that occur before we start iterating)\n\n1 second is only insufficient if one of our getUidsUpdated*Times functions takes over a second to iterate through its BPF map, where in practice the times I see are on the order of 10s of milliseconds. If the functions took 1 second I\u0027d be more worried about the huge regression in read performance compared to proc files than I would be about some times being off by some fraction of a second.",
      "parentUuid": "0c046456_4eef6a42",
      "revId": "f92ace0a56c6bae80c7f351e1fd6ae94d172c27f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c667ad3f_6fc19fe8",
        "filename": "libs/cputimeinstate/cputimeinstate.cpp",
        "patchSetId": 1
      },
      "lineNbr": 277,
      "author": {
        "id": 1069543
      },
      "writtenOn": "2020-02-03T23:51:25Z",
      "side": 1,
      "message": "The way it would take 1s is if an interrupt takes a long time or this process is preempted by an RT task that ends up taking a long time. Shouldn\u0027t happen often or on all devices, but it can happen.",
      "parentUuid": "3e9b6113_d2330c58",
      "revId": "f92ace0a56c6bae80c7f351e1fd6ae94d172c27f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b58bb7d5_daa3703e",
        "filename": "libs/cputimeinstate/cputimeinstate.cpp",
        "patchSetId": 1
      },
      "lineNbr": 277,
      "author": {
        "id": 1115183
      },
      "writtenOn": "2020-02-05T01:41:32Z",
      "side": 1,
      "message": "OK, I\u0027ve updated the commit message to note that 1) this mitigation doesn\u0027t completely eliminate the race and 2) the consequences aren\u0027t that bad even if the race does occur.",
      "parentUuid": "c667ad3f_6fc19fe8",
      "revId": "f92ace0a56c6bae80c7f351e1fd6ae94d172c27f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}