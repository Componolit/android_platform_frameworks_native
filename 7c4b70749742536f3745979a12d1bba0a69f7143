{
  "comments": [
    {
      "key": {
        "uuid": "4ddfd6f9_36bb0147",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 5
      },
      "lineNbr": 113,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2018-10-04T23:30:57Z",
      "side": 1,
      "message": "I don\u0027t like this. It overly couples the allocator, which is where should the string be placed, with how you get the return value back. Just have a char** output on readString so the return value can be returned.",
      "range": {
        "startLine": 111,
        "startChar": 0,
        "endLine": 113,
        "endChar": 88
      },
      "revId": "7c4b70749742536f3745979a12d1bba0a69f7143",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b330882a_6caeff5f",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 5
      },
      "lineNbr": 113,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2018-10-05T00:04:49Z",
      "side": 1,
      "message": "That also would be fine by me, but I think he was trying to avoid the extra copy that would be needed to go to a std::string if it were implemented that way.\n\nProbably not a noticable amount of overhead given that we\u0027re talking about IPC though?",
      "parentUuid": "4ddfd6f9_36bb0147",
      "range": {
        "startLine": 111,
        "startChar": 0,
        "endLine": 113,
        "endChar": 88
      },
      "revId": "7c4b70749742536f3745979a12d1bba0a69f7143",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "153eeb57_84dc22ce",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 5
      },
      "lineNbr": 113,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-10-05T00:11:44Z",
      "side": 1,
      "message": "The client of AParcel_readString will have some sort of a string representation locally (std::string, String8, MyString, MyBuffer, std::vector\u003cchar\u003e, etc...). This object (ideally pointed to by stringData so that the allocator has access to it) is what is actually interesting to the client. It\u0027s only in the trivial case where a char* is used that the char** would actually be interesting. In all other cases (including the one in binder_parcel_utils.h, the only Android user of this API, what AIDL is using which the vast majority of NDK users will use in order to continue to use AIDL trivially and seamlessly create Java \u003c-\u003e native interfaces), the char* will be dropped/ignored because it is also contained in stringData.\n\nThis example I\u0027m using in this header is degenerate, I agree, but the API is designed this way in order to support the following criteria:\n- the same side of the NDK library boundary has to allocate and de-allocate this stringt\n- libbinder_ndk copies the data from the wire only once\n- libbinder_ndk doesn\u0027t know the size of a string until it starts being read\n\nAnother way I could solve this problem is by creating a class like \"AString\" which allows libbinder_ndk to control the allocation/deletion of the string. Then we would need an AutoAString helper. I don\u0027t really like this (and don\u0027t want to do it for arrays/other data types/etc..). You also have shared your aversion with me to redefining structures like this (see b/68197287#comment10) which is why I didn\u0027t give this solution a second thought although I had considered it before.\n\nAlso, the current solution allows APIs built on top of this API to use whatever string representation they want to (std::string, etc..). This is a huge benefit since when large existing codebases use type X, they can continue to use that type w/o either a copy or refactoring the codebase.\n\n\n\u003e Probably not a noticable amount of overhead given that we\u0027re talking about IPC though?\nSure, but it is some overhead. We avoid it in HIDL. If these strings are kilobytes, it can add up. This has also been drilled into me as the reason why AIDL cpp originally chose to use utf16 in C++, hence why I am even more concerned about it. Personally, I\u0027m willing to abandon aesthetics in favor of performance. Especially since as I mentioned above the only likely user of this API provides a much nicer API w/ std::string in binder_parcel_utils.h and I can add more APIs for char* etc.. as needed.",
      "parentUuid": "4ddfd6f9_36bb0147",
      "range": {
        "startLine": 111,
        "startChar": 0,
        "endLine": 113,
        "endChar": 88
      },
      "revId": "7c4b70749742536f3745979a12d1bba0a69f7143",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc5b2363_222aea32",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 5
      },
      "lineNbr": 113,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2018-10-05T01:27:31Z",
      "side": 1,
      "message": "Let\u0027s imagine how this can be extended to things like readStringArray or readMap, etc.\n\ntypedef char*[] (*AParcel_stringarray_allocator)(void* data, size_t length)\ntypedef char* (*AParcel_string_allocator)(void* data, size_t length)\n\nAParcel_readStringArray(AParcel*, \n    AParcel_stringarray_allocator array_alloc, \n    AParcel_string_allocator string_alloc, void* data);\n\nThis doesn\u0027t work because there is no way for you to provide \u0027data\u0027 - which would be std::string - to the string_allocator.\n\n-------------\nI strongly believe you can greatly simply these APIs by returning the raw pointer to the parcel to the client and let the client to do the necessary conversion if needed.\n\nAParcel_readUtf16String(AParcel* parcel, void (*callback)(char16_t*, size_t))\nAParcel_readUtf16StringArray(AParcel* parcel void (*callback)(char16_t*[] array, size_t[] str_sizes, size_t array_size)\n\nThe array and str_sizes arrays are created by the API and are destroyed after the callback is returned. The important point is that strings themselves are never copied.\n\nI think this is okay because you will wrap these with the generated API from AIDL compiler where you can convert it to std::string in one pass.",
      "parentUuid": "153eeb57_84dc22ce",
      "range": {
        "startLine": 111,
        "startChar": 0,
        "endLine": 113,
        "endChar": 88
      },
      "revId": "7c4b70749742536f3745979a12d1bba0a69f7143",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c6bc6dbe_0fdb4b80",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 5
      },
      "lineNbr": 113,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-10-05T01:38:29Z",
      "side": 1,
      "message": "The problem is that it isn\u0027t easy to let the client do the conversion (many lines of code), and doing so would require exposing utf16 here (which I want to keep an implementation detail and avoid exposing). It would also require either an extra copy OR giving the client access to a pointer which is on the binder window (I wanted to avoid doing this as well since I don\u0027t want to have to expose the idea of a binder window in the NDK).\n\nFor the array/map/list cases, I can do something similar to here (the allocator will just be called multiple times and there will also be a vector allocator). This is similar to the cost of the existing libbinder wrappers (which have to call the std::vector/String16 function calls). For arrays of primitives, these will be read contiguously at once. In every case, this will have the same performance profile as the existing cpp backend sans some number of in-process function re-directs (which is the minimum I can provide).",
      "parentUuid": "dc5b2363_222aea32",
      "range": {
        "startLine": 111,
        "startChar": 0,
        "endLine": 113,
        "endChar": 88
      },
      "revId": "7c4b70749742536f3745979a12d1bba0a69f7143",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}